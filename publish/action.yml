name: 'publish-any'
description: 'Publish built packages to remote repositories (APT, APK, RPM, PACMAN)'
author: 'tty-pt'

inputs:
  name:
    description: 'Package name'
    required: true
  repo:
    description: 'Override "format" as target folder'
    required: false
    default: ''
  format:
    description: 'Package format'
    required: true
  deps:
    description: 'Generic dependencies'
    required: false
  deps_brew:
    description: 'Brew dependency names'
    required: false
    default: ''
  host:
    description: 'Remote server hostname'
    required: true
  user:
    description: 'Remote SSH username'
    required: true
  ssh_key:
    description: 'Private SSH key for upload'
    required: true
  gpg_key:
    description: 'Private GPG key (ASCII-armored, optional)'
    required: false
    default: ""
  gpg_keyid:
    description: 'Key ID or fingerprint for signing (optional)'
    required: false
    default: ""
  gpg_pass:
    description: 'Passphrase for GPG key (optional)'
    required: false
    default: ""
  abuild_key:
    description: 'Private abuild RSA key for APK signing (optional)'
    required: false
    default: ""
  abuild_pub:
    description: 'Public abuild key (optional)'
    required: false
    default: ""
  tap_token:
    description: 'Tap GH token'
    required: false
    default: ""

runs:
  using: 'composite'
  steps:
    - name: Configure SSH for Host
      shell: sh
      run: |
        mkdir -p $HOME/.ssh
        chmod 700 $HOME/.ssh

        echo "${{ inputs.ssh_key }}" > ~/.ssh/id_ed25519
        chmod 600 $HOME/.ssh/id_ed25519

        IP=$(getent hosts "$HOST" | awk '{print $1}' || true)

        ssh-keyscan -H "${{ inputs.host }}" >> "$HOME/.ssh/known_hosts"

        HOSTNAME="${{ inputs.host }}"
        USER="${{ inputs.user }}"

        cat > $HOME/.ssh/config <<EOF
        Host ${{ inputs.host }}
          HostName $HOSTNAME
          User $USER
          IdentityFile $HOME/.ssh/id_ed25519
          IdentitiesOnly yes
          UserKnownHostsFile /dev/null
          StrictHostKeyChecking no
          LogLevel ERROR
          BatchMode yes
          ConnectTimeout 5
        EOF
        chmod 600 $HOME/.ssh/config $HOME/.ssh/known_hosts
        cat $HOME/.ssh/config

        echo "✅ SSH config prepared for host"

    - name: Prepare enviroment vars
      run: |
        VERSION="${GITHUB_REF_NAME#v}"
        [ -n "$VERSION" ] || VERSION="$(date -u +%Y.%m.%d)"
        echo "VERSION=$VERSION" >> $GITHUB_ENV
        echo "PREFIX=/usr" >> $GITHUB_ENV
        arch="$(uname -m)"
        echo "arch=$arch" >> $GITHUB_ENV
        echo "iden=${{ inputs.name }}-${{ inputs.format }}-$arch" >> $GITHUB_ENV
        ofilep=${{ inputs.name }}-$VERSION-${{ inputs.format }}
        echo "ofilep=$ofilep" >> $GITHUB_ENV
        echo "ofile=$ofilep-$arch" >> $GITHUB_ENV

        if test -z "${{ inputs.repo }}"; then
          REPO=${{ inputs.format }}
        else
          REPO=${{ inputs.repo }}
        fi

        echo "REPO=$REPO" >> $GITHUB_ENV

        REPO_NAME="$(echo ${{ inputs.host }} | tr -d '.')"
        echo "REPO_NAME=$REPO_NAME" >> $GITHUB_ENV

      shell: sh

    - name: Download APK artifacts
      uses: actions/download-artifact@v4
      with:
        path: dist

    - name: Setup environment
      shell: sh
      run: |
        if [ -n "${{ inputs.gpg_key }}" ]; then
          mkdir -p "$HOME/.gnupg"
          chmod 700 "$HOME/.gnupg"
          echo "${{ inputs.gpg_key }}" | gpg --batch --yes --import
        fi

    - name: Acquire lock
      shell: sh
      run: |
        echo "⏳ Waiting for remote lock..."
        ssh -F $HOME/.ssh/config ${{ inputs.host }} "
          cd /var/www/htdocs/${{ env.REPO }}
          while ! mkdir publish.lock 2>/dev/null; do
            sleep 2
          done
          echo \$\$ > publish.lock/pid
          echo '✅ Remote lock acquired by PID' \$\$
        "

    - name: Prepare repo folder
      if: inputs.format != 'openbsd'
      shell: sh
      run: |
        mkdir -p repo

        find dist -path "*-${{ inputs.format }}-*"

        rsync -avz -e "ssh -F $HOME/.ssh/config" \
          "${{ inputs.user }}@${{ inputs.host }}:/var/www/htdocs/${{ env.REPO }}/" repo/

        cd repo
        find ../dist -mindepth 2 -maxdepth 2 \
          -path "*-${{ inputs.format }}-*" \
          -exec cp -r {} . \;

        if [ "$(uname)" = "Darwin" ]; then
          CHECKSUM="shasum -a 256"
        else
          CHECKSUM="sha256sum"
        fi

        $CHECKSUM `find . -type f` > SHA256SUMS
        cd - 2>/dev/null

        echo REPO FOLDER INIT
        find repo -type f

    - name: Publish APT repo
      if: inputs.format == 'deb'
      shell: sh
      run: |
        mkdir -p repo/pool/main

        cd repo
        for deb in $(find . -name "*.deb"); do
          pkg=$(dpkg-deb -f "$deb" Package)
          ver=$(dpkg-deb -f "$deb" Version)
          arch=$(dpkg-deb -f "$deb" Architecture)
          first=$(echo "$pkg" | cut -c1 | tr '[:upper:]' '[:lower:]')
          target="pool/main/$first/$pkg"
          mkdir -p "$target"
          test "$deb" != "./$target/${pkg}_${ver}_${arch}.deb" || continue
          mv "$deb" "$target/${pkg}_${ver}_${arch}.deb"
          mv "$deb.asc" "$target/${pkg}_${ver}_${arch}.deb.asc"
        done
        cd - 2>/dev/null

        mkdir -p repo/dists/stable/main/binary-amd64
        ORIGIN="${GITHUB_REPOSITORY_OWNER}"

        cat > apt-ftparchive.conf <<EOF
        Dir {
          ArchiveDir "repo";
          CacheDir   "repo/.cache";
        };
        Default {
          Packages::Compress ". gzip bzip2 xz";
        };
        TreeDefault {
          Directory  "pool/main";
          Packages   "dists/stable/main/binary-amd64/Packages";
        };
        BinDirectory "pool/main" {
          Packages "dists/stable/main/binary-amd64/Packages";
          Architectures "amd64";
          Section "main";
        };
        APT::FTPArchive::Release {
          Origin "$ORIGIN";
          Label "$ORIGIN";
          Suite "stable";
          Codename "stable";
          Components "main";
          Architectures "amd64";
          Description "APT repository for $ORIGIN";
        };
        EOF

        apt-ftparchive generate apt-ftparchive.conf
        gzip -kf repo/dists/stable/main/binary-amd64/Packages
        apt-ftparchive -c apt-ftparchive.conf release repo/dists/stable > repo/dists/stable/Release

        if [ -n "${{ inputs.gpg_key }}" ]; then
          mkdir -p /$HOME/.gnupg
          chmod 700 /$HOME/.gnupg
          echo "${{ inputs.gpg_key }}" | gpg --batch --yes --import
          mkdir -p repo/keyrings
          gpg --export --armor "${{ inputs.gpg_keyid }}" > repo/keyrings/archive-key.gpg

          gpg --batch --yes --local-user "${{ inputs.gpg_keyid }}" \
              --pinentry-mode loopback --passphrase "${{ inputs.gpg_pass }}" \
              --clearsign -o repo/dists/stable/InRelease repo/dists/stable/Release

          gpg --batch --yes --local-user "${{ inputs.gpg_keyid }}" \
              --pinentry-mode loopback --passphrase "${{ inputs.gpg_pass }}" \
              -abs -o repo/dists/stable/Release.gpg repo/dists/stable/Release
        fi

    - name: Import abuild key
      if: inputs.abuild_key != '' && inputs.format == 'apk'
      run: |
        mkdir -p /home/builder/.abuild
        echo "${{ inputs.abuild_key }}" > /home/builder/.abuild/${{ env.REPO_NAME }}.rsa
        chmod 600 /home/builder/.abuild/${{ env.REPO_NAME }}.rsa

        echo "${{ inputs.abuild_pub }}" > /home/builder/.abuild/${{ env.REPO_NAME }}.rsa.pub
        chmod 644 /home/builder/.abuild/${{ env.REPO_NAME }}.rsa.pub

        echo "PACKAGER_PRIVKEY=/home/builder/.abuild/${{ env.REPO_NAME }}.rsa" > /home/builder/.abuild/abuild.conf
        echo "PACKAGER='${{ inputs.host }} repo <repo@${{ inputs.host }}>'" >> /home/builder/.abuild/abuild.conf
        chown -R builder:builder /home/builder/.abuild
      shell: sh

    - name: Publish APK repo
      if: inputs.format == 'apk'
      shell: sh
      run: |
        mkdir repo/${{ env.arch }} || true
        cd repo/${{ env.arch }} || exit 1

        echo "Generating new APKINDEX.tar.gz..."
        rm -f APKINDEX.tar.gz
        apk index -o APKINDEX.tar.gz --allow-untrusted *.apk

        if [ -n "${{ inputs.abuild_key }}" ]; then
          echo "Signing APKINDEX..."
          mkdir -p /root/.abuild
          echo "${{ inputs.abuild_key }}" > /root/.abuild/${{ env.REPO_NAME }}.rsa
          chmod 600 /root/.abuild/${{ env.REPO_NAME }}.rsa
          export PACKAGER_REPOSITORY='@${{ env.REPO_NAME }}'
          abuild-sign -k /root/.abuild/${{ env.REPO_NAME }}.rsa APKINDEX.tar.gz
        else
          echo "⚠️ No abuild key provided — APKINDEX left unsigned."
        fi

        if [ -n "${{ inputs.abuild_pub }}" ]; then
          echo "Updating public key..."
          mkdir -p ../keys
          echo "${{ inputs.abuild_pub }}" > ../keys/${{ env.REPO_NAME }}.rsa.pub
        fi

        cd ..

    - name: Publish RPM repo
      if: inputs.format == 'rpm'
      shell: sh
      run: |
        mkdir -p repo/${{ env.arch }}

        cd repo
        for file in $(ls *.rpm); do
          mv $file ${{ env.arch }}
        done
        cd - 2>/dev/null

        # (re)generate metadata
        cd repo/${{ env.arch }}
        createrepo_c --update .

        # optional GPG signing of repomd.xml
        if [ -n "${{ inputs.gpg_key }}" ]; then
          mkdir -p "$HOME/.gnupg"
          chmod 700 "$HOME/.gnupg"
          echo "${{ inputs.gpg_key }}" | gpg --batch --yes --import
          gpg --batch --yes --pinentry-mode loopback \
              --passphrase "${{ inputs.gpg_pass }}" \
              --detach-sign --armor -u "${{ inputs.gpg_keyid }}" repodata/repomd.xml || \
              echo "⚠️  repomd.xml signing failed"
        fi

        # generate .repo file
        cd ..
        {
          echo "[${{ env.REPO_NAME }}]"
          echo "name=${{ env.REPO_NAME }} Repository"
          echo "baseurl=https://${{ inputs.host }}/rpm/\$basearch"
          echo "enabled=1"
          echo "gpgcheck=1"
          echo "gpgkey=https://${{ inputs.host }}/rpm/RPM-GPG-KEY-${{ env.REPO_NAME }}"
        } > "${{ env.REPO_NAME }}.repo"

        # export public GPG key if any
        if [ -n "${{ inputs.gpg_keyid }}" ]; then
          gpg --export --armor "${{ inputs.gpg_keyid }}" > "RPM-GPG-KEY-${{ env.REPO_NAME }}"
        fi

    - name: Publish PACMAN / PACMAN_MINGW repo
      if: inputs.format == 'pacman' || inputs.format == 'pacman_mingw'
      shell: sh
      run: |
        cd repo
        for file in $(ls *.tar.zst*); do
          mv $file ${{ env.arch }}
        done

        echo "Updating Pacman repo '${{ env.REPO_NAME }}'..."

        if [ -n "${{ inputs.gpg_key }}" ]; then
          mkdir -p "$HOME/.gnupg"
          chmod 700 "$HOME/.gnupg"
          echo "${{ inputs.gpg_key }}" | gpg --batch --yes --import
          GPG_OPTS="-s -k '${{ inputs.gpg_keyid }}'"
        else
          GPG_OPTS=""
        fi

        cd ${{ env.arch }}
        for pkg in *.pkg.tar.*; do
          case "$pkg" in
            *.asc|*.sig) continue ;;  # skip detached signatures
          esac
          pkgs="$pkgs $pkg"
        done

        eval repo-add $GPG_OPTS "${{ env.REPO_NAME }}.db.tar.gz" $pkgs

        ln -sf "${{ env.REPO_NAME }}.db.tar.gz" "${{ env.REPO_NAME }}.db"
        ln -sf "${{ env.REPO_NAME }}.files.tar.gz" "${{ env.REPO_NAME }}.files"
        cd ..
        {
          echo "[${{ env.REPO_NAME }}]"
          echo "SigLevel = Required DatabaseOptional"
          echo "Server = https://${{ inputs.host }}/${{ env.REPO }}/\$arch"
        } > "${{ env.REPO_NAME }}.conf"

        if [ -n "${{ inputs.gpg_keyid }}" ]; then
          gpg --export --armor "${{ inputs.gpg_keyid }}" > "key-${{ env.REPO_NAME }}.pub"
        fi

    - name: Publish macOS repo
      if: inputs.format == 'brew'
      shell: sh
      run: |
        ( cd "repo" && \
          shasum -a 256 `find . -type f` > SHA256SUMS )

        if [ -n "${{ inputs.gpg_key }}" ]; then
          mkdir -p "/$HOME/.gnupg"
          chmod 700 "/$HOME/.gnupg"
          echo "${{ inputs.gpg_key }}" | gpg --batch --yes --import
          ( cd "repo/versions/${{ env.VERSION }}" && \
            gpg --batch --yes --pinentry-mode loopback --passphrase "${{ inputs.gpg_pass }}" \
                --detach-sign --armor -u "${{ inputs.gpg_keyid }}" SHA256SUMS || true )
          # publish pubkey for users
          gpg --export --armor "${{ inputs.gpg_keyid }}" > repo/key.pub || true
        fi

    - name: Generate formula (BREW)
      if: inputs.format == 'brew'
      run: |
        FORMULA_PATH="${{ inputs.name }}.rb"
        find repo -type f -name "*.tar.gz"
        for f in $( find repo -type f -name "*.tar.gz"); do
          shasum -a 256 $f | cut -d' ' -f1 > $f.sha
        done

        CLASS_NAME="$(echo "${{ inputs.name }}" | perl -pe 's/(?:^|_)([a-z])/\u$1/g')"

        {
          echo "class ${CLASS_NAME} < Formula"
          echo "  desc \"${{ inputs.name }} binary package\""
          echo "  homepage \"https://github.com/${{ github.repository }}\""
          URL_PREFIX="https://github.com/${{ github.repository }}/releases/download/v${VERSION}/${{ env.ofilep }}"
          echo "  if Hardware::CPU.arm?"
          echo "    url \"$URL_PREFIX-arm64.tar.gz\""
          echo "    sha256 \"$(cat repo/$ofilep-arm64.tar.gz.sha)\""
          echo "  else"
          echo "    url \"$URL_PREFIX-x86_64.tar.gz\""
          echo "    sha256 \"$(cat repo/$ofilep-x86_64.tar.gz.sha)\""
          echo "  end"
          echo "  version \"${{ env.VERSION }}\""

          deps="${{ inputs.deps_brew || inputs.deps }}"
          # Add dependencies if defined
          if [ -n "$deps" ]; then
            for dep in $(echo "$deps" | tr ',' ' '); do
              echo "  depends_on \"$dep\""
            done
          fi
          echo ""
          echo "  def install"
          echo "    prefix.install Dir[\"*\"]"
          echo "  end"
          echo ""
          echo "  test do"
          echo "    system \"true\""
          echo "  end"
          echo "end"
        } > "$FORMULA_PATH"

        echo "Generated Homebrew formula:"
        cat "$FORMULA_PATH"
      shell: sh

    - name: Push formula to tty-pt/tap
      if: inputs.format == 'brew'
      env:
        TAP_TOKEN: ${{ inputs.tap_token }}
      run: |
        TAP_REPO="https://x-access-token:${TAP_TOKEN}@github.com/tty-pt/tap.git"
        TAP_DIR="tap"

        git clone --depth=1 "$TAP_REPO" "$TAP_DIR"
        mkdir -p "$TAP_DIR/Formula"
        cp *.rb "$TAP_DIR/Formula/"

        cd "$TAP_DIR"
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git add Formula/*.rb
        git commit -m "Update ${{ inputs.name }}} to v${{ env.VERSION}}:-${{ github.ref_name }}" || true
        git push origin main || echo "No changes to push."
      shell: bash

    - name: Update repo
      if: inputs.format != 'openbsd'
      shell: sh
      run: |
        echo "Syncing repository..."
        rsync -avz -e "ssh -F $HOME/.ssh/config" \
          repo/ "${{ inputs.user }}@${{ inputs.host }}:/var/www/htdocs/${{ env.REPO }}/"

    - name: Publish OpenBSD repo
      if: inputs.format == 'openbsd'
      shell: sh
      run: |
        echo "🦫 Publishing OpenBSD packages..."

        ARCH=$(ssh -F "$HOME/.ssh/config" ${{ inputs.host }} "uname -m")
        TARGET="/var/www/htdocs/openbsd/$ARCH"

        scp -F $HOME/.ssh/config \
        ./dist/${{ env.iden }}/${{ env.ofile }}.tgz \
          ${{ inputs.host }}:$TARGET/${{ inputs.name }}-${{ env.VERSION }}.tgz

        LOCAL="/var/www/var/ci-chroot/tmp/"
        ssh -F "$HOME/.ssh/config" ${{ inputs.host }} <<EOF
          set -e
          cd $TARGET

          doas /usr/local/sbin/ci-sign-pkg \
            ${{ inputs.name }}-${{ env.VERSION }}.tgz

          echo 🧾 Generating package index...
          rm -f index.txt
          ls -nlT >index.txt

          chmod 644 index.txt
          sha256 -b *.tgz > SHA256
          doas /usr/local/sbin/ci-sign-repo

          echo "✅ OpenBSD package index created at $TARGET/index.txt"
        EOF

    - name: Release lock
      if: always()
      shell: sh
      run: |
        echo "🔓 Releasing remote lock..."
        ssh -F $HOME/.ssh/config ${{ inputs.host }} "
          cd /var/www/htdocs/${{ env.REPO }}
          rm -rf publish.lock
        " || true
        echo '✅ Remote lock released.'
